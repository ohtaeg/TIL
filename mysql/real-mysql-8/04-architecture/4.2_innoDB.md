# InnoDB 스토리지 엔진 아키텍쳐
- InnoDB는 레코드 기반의 잠금을 제공한다. 특징은 다음과 같다.

## PK에 의한 클러스터링
- InnoDB의 모든 테이블은 PK 기준으로 클러스터링되어 저장된다.
    - 즉, PK 순서대로 디스크에 저장된다.
    - 이로 인해 PK는 클러스터링 인덱스이므로 PK를 이용한 레인지 스캔이 빠르다.
    - 이로 인해 옵티마이저에서 다른 보조 인덱스보다 PK 인덱스를 높은 확률로 선택한다.

## FK 지원
- InnoDB에서만 지원한다.
- FK로 관계가 맺어진 경우 데이터 변경시 연관 테이블에 데이터가 있는지 확인하는 작업이 필요하므로
  잠금이 여러 테이블에 전파되고 데드락이 발생할 수 있다.

## MVCC
[MySQL :: MySQL 8.0 Reference Manual :: 15.3 InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)
- Multi Version Concurrency Control
  - 하나의 레코드에 대해서 데이터를 여러곳에서 여러 버전을 가지고 있어서 Multi Version이라고 한다.
- 데이터 변경이 발생하고 커밋이 되지 않은 상태에서 **잠금을 사용하지 않고 일관된 읽기를 제공**하는 것을 뜻한다.
- InnoDB의 `UndoLog`를 이용해 기능을 구현한다.
- 데이터를 변경을 하고 아직 커밋이나 롤백이 되지 않은 상태에서 레코드를 조회하면 어디를 조회할까?
    - 디스크 변경되었을까? → 시점에 따라 디스크에 업데이트 되어있을 수도 있고 아닐수도 있다.
    - 게다가 중요한 것은 격리 수준에 따라 다르다!
    - **READ_COMMITTED, REPETABLE_READ, SERIALIZABLE** 인 경우 아직 커밋이 되지 않았기에
      **InnoDB 버퍼 풀** or 디스크가 아닌 변경되기 이전의 내용을 보관하고 있는 **Undo Log** 영역의 데이터를 반환한다.

## 잠금 없는 일관된 읽기

- Non Locking Consistent Read
- MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.
- 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.
- 레코드가 변경되고 커밋이 안되었더라도 **Undo Log**영역에서 변경되기 이전 버전의 데이터를 읽을 수 있다.

## 자동 데드락 감지
- InnoDB는 데드락 감지 스레드를 가지고 있어서 교착 상태에 빠진 트랜잭션을 감시한다.
- 교착 상태에 빠진 트랜잭션들을 종료할 때 먼저 종료하는 조건은 트랜잭션의 Undo Log의 양이다.
  - **Undo Log의 레코드 양이 적은 트랜잭션이 롤백의 대상이 된다.**
  - 롤백할 내용이 적다는 것으로, 서버의 부하도 적다.
- 스토리지 엔진보다 상위인 **MySQL 엔진에서 관리되는 테이블 잠금은 볼 수가 없다.**
  - innodb_table_locks 시스템 변수를 활성화한다면, 레코드 잠금뿐만 아니라 테이블 잠금도 감지할 수 있게 된다. 
    - 책에서 가능하면 해당 변수를 활성화하는 것을 추천하고 있다.
- 데드락 감지 스레드는 잠금 목록을 검사할 때 잠금 상태가 변경되지 않도록 잠금 목록이 담긴 테이블에 새로운 잠금을 건다.
- 이로인해 동시 처리하는 스레드가 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려져서 쿼리를 처리중인 스레드는 지연되고 서비스에 악영향을 미치게 된다.
- innodb_deadlock_detect 시스템 변수를 통해 데드락 감지 스레드 활성화 여부를 제어할 수 있다.
  - OFF로 비활성화한다면 두 트랜잭션이 교착 상택 되었을 때 무한히 대기하게 된다.
  - innodb_lock_wait_time 시스템 변수를 통해 데드락 상황에서 일정 시간이 지나면 에러를 반환하도록 할 수 있다.
  - innodb_deadlock_detect를 OFF로 한다면 innodb_lock_wait_time 값을 50초보다 낮게 설정하는 것을 권장한다.