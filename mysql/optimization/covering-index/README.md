# 커버링 인덱스
- 인덱스를 이용해 쿼리 처리시, 인덱스로 설정된 컬럼만으로 충분하지 않아 실제 테이블 레코드에 접근하는 경우가 있다.
- 즉, 인덱스 스캔시 쭉 읽고 b-tree에 저장된 인덱스의 키와 레코드 주소를 이용해 실제 테이블에서 레코드를 읽어와야한다.
  - 이런 경우 레코드 한 건 한 건 단위로 랜덤 IO가 발생하게 된다.
- `커버링 인덱스`를 사용하면 테이블 레코드에 접근하지 않고 인덱스에 포함된 컬럼들만으로 쿼리를 처리할 수 있는 경우 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 IO가 줄어들고 성능이 그만큼 빨라진다. 
  - 인덱스만으로 쿼리를 처리하여 테이블 레코드에 접근하지 않아도 되는 인덱스를 뜻한다.
- 인덱스 탐색 과정은 다음과 같다.

1. 인덱스 탐색을 통해 조건을 만족하는 값의 위치를 찾아 인덱스를 쭉 읽는다.
2. 1번에서 읽어들인 인덱스 키와 레코드 주소를 이용해서 레코드를 읽어온다.

- 이때 커버링 인덱스는 1번 과정을 통해 쿼리를 처리하여 2번을 수행하지 않아 읽기 성능을 향상시킬 수 있다.

<br>

## 커버링 인덱스를 적용할 수 있는 상황
1. 특정 컬럼을 자주 조회
    - 인덱스를 사용중이지만 특정 컬럼 때문에 테이블에 접근하는게 비용이 크게 느껴지는 경우
2. 조인 연산 비용 줄이기
    - 여러 테이블을 조인할 때 발생하는 비용을 줄이기 위해서 사용
3. 읽기 성능이 중요한 경우
    - 인덱스 레벨에서만 필터링해서 읽기 성능이 필요한 경우 적용

<br>

## 커버링 인덱스 적용시 고려해야할 내용은?
커버링 인덱스를 만드는 과정은 인덱스를 추가하거나 기존 인덱스에 컬럼을 추가하는 방식일 것이다.

그러다보니 인덱스 블록 크기가 커짐으로 인해 인덱스 스캔 탐색 비용이 증가할 수 있다.

- **인덱스 크기**
  - 인덱스에 많은 컬럼이 담기면 인덱스가 커지고, 인덱스 블록에 들어갈 데이터 수는 줄어들기 때문에 인덱스 스캔 비용이 커질 수 있다.
- **컬럼 크기**
  - 게다가 큰 크기의 컬럼 (varchar(255))은 위와 같은 이유로 비효율적일 수 있다.
- **쓰기 비용**
  - 인덱스 추가나, 인덱스에 컬럼 추가시 레코드가 수정되면 인덱스도 같이 수정되어야 하기 때문에 <br>
    변경이 잦은 데이터를 인덱스에 포함시키면 비용이 커진다.
- **카디널리티**
  - 카디널리티가 낮은 값의 컬럼을 인덱스로 추가하는 경우, 읽기 성능이 향상되지 않을 수 있다.