# Chapter3. SOLID 원칙

## SRP 원칙
- `책임`이란?
  - 책임은 보통 `해야하는 것` 혹은 `할 수 있는 것`으로 간주한다.
  - 객체는 `무엇을 알고 있는가` 와 `무엇을 할 수 있는가` 로 구성된다.
  - 객체에 책임을 할당할 때 `어떤 객체보다도 정보를 잘 알고 작업을 잘할 수 있는` 객체에게 해야한다.
- 설계 원칙을 학습하는 이유는 예측하지 못한 변경사항이 발생하더라도 영향 받는 부분을 줄이기 위해서다.
- **그렇기에 책임은 곧 `변경하려는 이유`, `사용하려는 기능 or 객체가 수정될 가능성`과 같다.**
- 어떤 객체가 다른 객체에 의존하는 이유는 무엇인가를 고민해보자.
  - 대상이 객체에 할당된 책임을 이용하고 싶기 때문!

#### 좀 더 책임에 대해 고촬해보자.
- 책임의 범위를 어디까지 볼것인가? 가령, 객체가 많은 책임을 부여했다는 지표는 무엇일까?
  - 생성 책임 분리: 팩토리 메서드 패턴이 존재하는 이유
  - 조립 책임 : DIP, 의존성 주입
  - 상태 책임 : 
    - 메소드보다 필드 선언을 더 중요하게 생각해야한다.
    - 특정 필드가 선언되어있으면 그 선언된 객체에게 보통 책임을 뒤집어 씌우게 된다.
    - getter와 같이 외부에 필드를 노출하면 결합도가 높아지게 된다.
- 책임을 적게 가지게 하는 것은 그만큼 객체가 여러 대상으로 분산되는 것은 아닐까?
  - 책임이 분할되면 구조는 복잡해질 수 있으나 내부 가시성이 좋아지고, 결합도가 낮아지는 장점이 있다.
  - 한곳에 몰려있는 것보다 분산되어있는 것이 더 효율적일 것 같다.
  - 또한 분리하다보면 단위가 작아지므로 테스트 및 리팩토링의 장점도 있을 것 같다.



#### 산탄총 수술
- 만약 하나의 책임이 여러 곳에 흩어져있으면 마치 산탄총에 맞은 것과 같다고 한다.
- 산탄총에 맞으면 여러 부위를 수술해야하는 것 처럼 변경으로 인해 여러 클래스를 건드려야한다.
- 이를 해결하기 위해서는 기능을 별개의 클래스로 분리해 책임을 담당하게 하여 여러곳에 흩어진 공통 책임을 한곳에 모으는 것
- 독립 클래스를 구현하더라도 구현된 기능들을 호출하고 사용하는 코드는 어딘가에 포함되거나 호출되어야 한다.

----

## OCP 원칙
- 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있어야 한다.
  

