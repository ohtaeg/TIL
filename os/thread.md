# 스레드 종류
## Hardware thread
- 코어에서 실행되는 연산에 비해 메모리에서 데이터를 기다리는 시간이 상대적으로 꽤 오래 걸린다.
- 메모리의 데이터를 기다리는 동안 코어가 아무일도 하지 않는다면 비효율적이기 때문에 메모리를 기다리는 동안 다른 스레드를 실행한다.
- 이때 실행되는 스레드들이 하드웨어 스레드이다.
- OS 관점에서 가상의 코어라고도 볼 수 있다.
  - CPU 레벨에서의 쓰레드
- 인텔의 hyper-threading
  - 물리적인 코어마다 하드웨어 스레드가 두 개
- 싱클 코어에 하드웨어 스레드가 두 개 라면 OS는 이 CPU를 듀얼 코어로 인식하고 듀얼 코어에 맞춰서 OS 레벨의 스레드들을 스케줄링한다.
- 인텔 듀얼 코어 CPU에 hyper-threading이 적용됐다면 하드웨어 스레드는 몇 개인가?
  - 2개의 코어 * 하드웨어 스레드 2개 = 총 4개
  - 그럼 이때 OS는 이 CPU를 듀얼 코어로 인식하지 않고 쿼드 코어로 인식한다.

<br>

## OS thread
- OS 커널 레벨에서 생성되고 관리되는 스레드
- `CPU에서 실제로 실행되는 단위, CPU 스케줄링의 단위`
- OS 스레드의 컨텍스트 스위칭은 커널이 개입
  - 유저 모드 -> 커널 모드로 전환이 되고 여러 커널 코드가 CPU에서 실행되기 때문에 비용이 발생
- 사용자 코드와 커널 코드 모두 OS 스레드에서 실행된다.
- OS 스레드는 다음과 같이 불리기도 한다.
  - 네이티브 스레드
  - 커널 스레드
  - 커널-레벨 스레드
  - OS-레벨 스레드
- 만약 OS 스레드 8개가 hyper-threading이 적용된 인텔 듀얼 코어 위에서 동작한다면 OS 스레드들을 어떻게 코어에 균등하게 할당할 수 있는가?
  - 2개의 코어 * 하드웨어 스레드 2개 = 총 4개
  - OS에서 입장에서 코어 4개로 인식하게 되고 OS 스레드 8개는 2개씩 각각 할당하게 된다.

<br>

## User thread
- 유저-레벨 스레드라고 불리며, `스레드 개념을 프로그래밍 레벨에서 추상화 한 것 `
  ```
  Thread thread = new Thread();
  thread.start();
  ```
- 유저 스레드가 CPU에서 실행되려면 OS 스레드와 반드시 연결돼야 한다.
- 유저 스레드와 OS 스레드를 어떻게 연결시킬 것인가? 3가지 연결 방식이 있다.
1. `One-to-One model`
   - 오늘날 자바 스레드 모델, 1:1 매핑
   - 스케줄링을 포함한 스레드 관리를 OS에 위임 (커널이 수행)
     - 자바는 threading model을 직접 JVM에서 관리하는 것이 아니라 그 아래 단의 OS에 위임
   - 멀티 코어 환경에서 활용
   - 하나의 스레드가 Blocking이 되더라도 다른 스레드는 잘 동작
   - race condition 발생 여지가 있음
2. Many-to-One model
   - 유저 스레드가 여러개 있고 OS 스레드 1개에 매핑
   - 유저 레벨에서만 컨텍스트 스위칭이 발생해 커널이 개입하지 않아 유저 스레드 간의 컨텍스트 스위칭이 빠름
   - OS 스레드 1개밖에 없기 떄문에 race condition이 거의 없음 (싱글 스레드)
   - OS 스레드가 1개밖에 없기 때문에 멀티 코어를 활용하지 못함
   - 유저 스레드 중 하나가 Blocking이 되면 OS 스레드가 1개 밖에 없기 때문에 전체 유저 스레드들도 Block이 된다.
3. Many-to-Many model
   - One-to-One model 과 Many-to-One model을 합친 것
   - 유저 스레드 간의 컨텍스트 스위칭이 빠름
   - 멀티 코어 활용
   - 하나의 스레드가 Blocking이 되더라도 다른 스레드는 잘 동작
   - 구현이 매우 어려움
   - go 는 Many to Many Model
- 기술 문서에서는 유저 스레드를 맥락에 따라 OS와는 독립적으로 유저 레벨에서 스케줄링되는 스레드라고 설명하기도 한다.
- Many-to-One, Many-to-Many 모델의 유저 스레드들만 한정해서 지칭하기도 한다.