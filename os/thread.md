# 스레드 종류
## Hardware thread
- 코어에서 실행되는 연산에 비해 메모리에서 데이터를 기다리는 시간이 상대적으로 꽤 오래 걸린다.
- 메모리의 데이터를 기다리는 동안 코어가 아무일도 하지 않는다면 비효율적이기 때문에 메모리를 기다리는 동안 다른 스레드를 실행한다.
- 이때 실행되는 스레드들이 하드웨어 스레드이다.
- OS 관점에서 가상의 코어라고도 볼 수 있다.
  - CPU 레벨에서의 쓰레드
- 인텔의 hyper-threading
  - 물리적인 코어마다 하드웨어 스레드가 두 개
- 싱클 코어에 하드웨어 스레드가 두 개 라면 OS는 이 CPU를 듀얼 코어로 인식하고 듀얼 코어에 맞춰서 OS 레벨의 스레드들을 스케줄링한다.
- 인텔 듀얼 코어 CPU에 hyper-threading이 적용됐다면 하드웨어 스레드는 몇 개인가?
  - 2개의 코어 * 하드웨어 스레드 2개 = 총 4개
  - 그럼 이때 OS는 이 CPU를 듀얼 코어로 인식하지 않고 쿼드 코어로 인식한다.

<br>

## OS thread
- OS 커널 레벨에서 생성되고 관리되는 스레드
  - `CPU에서 실제로 실행되는 단위, CPU 스케줄링의 단위`
- OS 스레드의 컨텍스트 스위칭은 커널이 개입
  - 유저 모드 -> 커널 모드로 전환이 되고 여러 커널 코드가 CPU에서 실행되기 때문에 비용이 발생
- 유저 레벨 코드와 커널 코드 모두 OS 스레드에서 실행된다.
  - 유저 모드에서 실행되는 유저 레벨의 코드들도 (CPU 관점에서 보면) OS 스레드에서 실행.
  - CPU와 프로그램의 인터페이스 역할을 하는 것이 OS이고, CPU 등 하드웨어 입장에서는 OS만 바라보기 때문에 OS 스레드 혹은 커널 스레드가 있어야 CPU에서 실행된다.
  - 프로그램이 CPU에서 실행된다는 것은 개발자가 작성한 자바 코드들이 OS 스레드에 담기게 되고, 자바 코드는 자바 스레드에서 실행되지만 최종적으로 OS 스레드에 의해 CPU에서 실행

<br>

- 커널 모드에서만 동작하는 스레드는 아니다. 스레드의 생성과 실행/관리를 커널이 주관한다는 의미에서 커널 레벨 스레드라고 부르는 것이지, 커널 모드에서만 실행한다는 의미가 아니다.
- OS 스레드는 다음과 같이 불리기도 한다.
  - 네이티브 스레드
  - 커널 스레드
  - 커널-레벨 스레드
  - OS-레벨 스레드
- 만약 OS 스레드 8개가 hyper-threading이 적용된 인텔 듀얼 코어 위에서 동작한다면 OS 스레드들을 어떻게 코어에 균등하게 할당할 수 있는가?
  - 2개의 코어 * 하드웨어 스레드 2개 = 총 4개
  - OS에서 입장에서 코어 4개로 인식하게 되고 OS 스레드 8개는 2개씩 각각 할당하게 된다.

<br>

## User thread
- 유저-레벨 스레드라고 불리며, `스레드 개념을 프로그래밍 레벨에서 추상화 한 것 `
  ```
  Thread thread = new Thread();
  thread.start();
  ```
- 유저 스레드가 CPU에서 실행되려면 OS 스레드와 반드시 연결돼야 한다.
- 유저 스레드와 OS 스레드를 어떻게 연결시킬 것인가? 3가지 연결 방식이 있다.
1. `One-to-One model`
   - 오늘날 자바 스레드 모델, 1:1 매핑
   - 스케줄링을 포함한 스레드 관리를 OS에 위임 (커널이 수행)
     - 자바는 threading model을 직접 JVM에서 관리하는 것이 아니라 그 아래 단의 OS에 위임
   - 멀티 코어 환경에서 활용
   - 하나의 스레드가 Blocking이 되더라도 다른 스레드는 잘 동작
   - race condition 발생 여지가 있음
2. Many-to-One model
   - 유저 스레드가 여러개 있고 OS 스레드 1개에 매핑
   - 유저 레벨에서만 컨텍스트 스위칭이 발생해 커널이 개입하지 않아 유저 스레드 간의 컨텍스트 스위칭이 빠름
   - OS 스레드 1개밖에 없기 떄문에 race condition이 거의 없음 (싱글 스레드)
   - OS 스레드가 1개밖에 없기 때문에 멀티 코어를 활용하지 못함
   - 유저 스레드 중 하나가 Blocking이 되면 OS 스레드가 1개 밖에 없기 때문에 전체 유저 스레드들도 Block이 된다.
3. Many-to-Many model
   - One-to-One model 과 Many-to-One model을 합친 것
   - 유저 스레드 간의 컨텍스트 스위칭이 빠름
   - 멀티 코어 활용
   - 하나의 스레드가 Blocking이 되더라도 다른 스레드는 잘 동작
   - 구현이 매우 어려움
   - go 는 Many-to-Many Model
- 기술 문서에서는 유저 스레드를 맥락에 따라 OS와는 독립적으로 유저 레벨에서 스케줄링되는 스레드라고 설명하기도 한다.
- Many-to-One, Many-to-Many 모델의 유저 스레드들만 한정해서 지칭하기도 한다.

<br>

### 커널(OS)스레드는 CPU인터럽트에의해 스위칭되는데, 유저레벨스레드는 어떻게 다른 유저 레벨 스레드로 스위칭될 수 있을까?
- 프로그래밍 언어가 어떻게 구현했는지에 따라 여러 방식이 있을 수 있다.
- 언어가 제공하는 virtual machine이 담당할수도 있지 않을까 한다.
- 대표적인 예가 아주 초창기 자바 버전에서는 green thread가 있었는데 예가 유저 스레드이다.
  - 그리고 이 친구들의 스케줄링을 담당하는 것은 java virtual machine이였다.
- 또한 개발자가 코드로 직접 유저 레벨 스레드가 언제 스위칭할지 명시할 수 있다.
  - 파이썬의 코루틴이 이와 같은 방식으로 동작한다.

<br>

## Green thread
- Java 초창기 버전(1.1, 1.2)은 **Many-to-One** 스레딩 모델을 사용
  - 이때 이 유저 스레드들을 그린 스레드라고 불렀음
- 오늘날 그린 스레드의 의미가 확장되어 OS와는 독립적으로 유저 레벨에서 스케줄링되는 스레드라고 불림
  - Many-to-One, Many-to-Many
  - 맥락에 따라 유저 스레드 개념과 동일, 유저 레벨에서 자체적으로 관리되고 스케줄링 되는 스레드는, 유저 스레드 혹은 그린 스레드라고 불린다.

<br>

## Kernel thread
- 실제 os 커널이 수행하는 스케쥴링, 자원관리, 감시, 하드웨어 이벤트 모니터링이나 디스크와 RAM 사이에 데이터 이동 등등의 커널이 하는 핵심 역할을 백그라운드에서 **데몬처럼 수행하는 스레드**
- OS 스레드와 같은 의미이기도 하지만 맥락에 따라 커널 코드를 실행하는 OS 커널의 역할을 수행하는 스레드