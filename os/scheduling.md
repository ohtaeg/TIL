# CPU 스케줄링

## CPU 스케줄러
- 각 프로그램마다 CPU 버스트와 IO 버스트가 균일하지 않기 때문에 CPU가 놀지 않도록 프로세스를 선택하는 역할을 한다.
- `ready` 상태에 있는 프로세스들 중에 어떤 프로세스를 선택할지 결정하는 운영체제 코드이다.

<br>

- 오늘날 프로세스들의 CPU 버스트를 분석해보면 대부분 짧은 CPU 버스트 분포가 많다. 
  - 즉, CPU를 잠깐 사용하고 I/O 작업을 수행하는 프로세스들이 많다는 뜻이다.
- CPU 버스트가 짧은 프로세스는 대부분 빠른 응답이 중요한 사용자와 인터액션을 수행하는 작업을 수행한다. 
- 빠른 응답을 제공해야하기 때문에 CPU 스케줄링을 할 때 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용할 수 있는 스케줄링이 필요하다.

<br>

- CPU 스케줄링이 발생하는 상황은 다음과 같다.
1. `running` -> {`blocked` or `waiting`}
   - 실행 중인 상태에 있던 프로세스가 I/O 요청 등에 의해 대기 상태로 바뀌는 경우
2. `running` -> `ready`
   - 실행 중인 상태에 있던 프로세스가 인터럽트 콜에 의해 준비 상태로 바뀌는 경우
3. {`blocked` or `waiting`} -> `ready`
   - I/O 작업이 완료가 되어 인터럽트가 발생하고 그 결과 프로세스 상태가 준비 상태로 바뀌는 경우
4. `running` -> `terminated`
   - 실행 상태에 있는 프로세스가 종료되는 경우 

## 디스패처
- CPU 스케줄러가 어떤 프로세스에게 CPU를 할당해야 할지 결정하고나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요한데, 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 도와주는 커널 모듈을 말한다.
  - 즉, 스케줄러가 ready 상태에 있는 프로세스들 중에 어떤 프로세스를 선택할지 결정했다면
  - 디스패처는 선택된 프로세스에게 CPU를 할당하는 역할을 한다.
  - - _CPU와 관련된 작업들은 민감한 작업으로써 OS에서 조심스럽게 다뤄야 하기 때문에 보통 `커널 모드`에서 실행한다는 것을 기억해두자._
- 컨텍스트 스위칭을 디스패쳐가 한다.
- `커널 모드` -> `유저 모드`로 전환하는 것도 디스패처가 하는 역할 중 하나이다.
- 새롭게 선택된 프로세스가 어디서부터 작업을 시작해야할지 실행되어야할 위치로 프로세스를 이동시키는 역할도 한다. <br>
즉,
1. 디스패처는 커널 모드에서 현재 수행중이던 프로세스의 문맥을 PCB에 저장하고, 새로운 프로세스의 문맥을 PCB로부터 복원
2. 커널 모드에서 새로운 문맥을 복원후 CPU를 할당받게 해야하기 때문에 `유저 모드`로 전환 후 프로세스에게 CPU 제어권을 넘기게 된다.
3. 복원된 문맥을 통해 PC로 부터 현재 수행할 주소를 찾을 수 있게 된다.

- 이와 같이 디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기 걸리는 시간은 컨텍스트 스위칭 오버헤드에 해당한다.

<br>

## 스케줄링 선점 방식

### 비선점 (Nonpreemptive)
- CPU를 획득한 프로세스가 **스스로** CPU를 반납하기 전까지 CPU를 빼앗기지 않는 스케줄링 방법
- `running` 상태인 프로세스가 OS가 강제로 개입하는 일 없이 **자발적으로** `ready`, `waiting`, `terminated`으로 전환되어 다른 프로세스에게 CPU를 양보하는 것
- 프로세스가 끝날때까지 OS가 기다려주기 때문에 신사적이다
- 다른 프로세스에게 CPU를 사용하도록 양보하기에 협력적이다. 
- 만약 작업이 긴 프로세스라 할지라도 OS가 끝날때까지 기다려주기 때문에 느린 응답성이 특징이다.
  - 다른 프로세스들은 계속 대기하고 있게 된다.

### 선점 (Preemptive)
- CPU를 획득한 프로세스가 CPU를 계속 사용하기를 원하더라도 OS가 강제로 빼앗을 수 있는 스케줄링 방법
  - time slice를 부여한 후 타이머 인터럽트를 발생시켜 `ready` 상태로 전환시켜 대기시키거나
  - I/O 작업이 완료된 프로세스가 인터럽트 당한 프로세스보다 우선순위가 높아, 인터럽트 당한 프로세스가 아닌 I/O 작업이 완료된 프로세스에게 CPU를 할당하거나
  - `running` 상태인 프로세스보다 ready 상태에 있는 프로세스가 우선순위가 높아 아직 time slice가 끝나지 않았는데 `ready`로 전환시킨다.
- 비선점 방식이 하는 일 + OS 개입으로 인해 적극적이고 강제적인 스케줄링 방법.
- 여러 프로세스가 CPU를 자주 획득하는 방법이다보니 빠른 응답성이 특징이다.

<br>

## 스케줄링 알고리즘
### FCFS (First Come First Served)
- 프로세스가 준비 큐에 도착한 순서대로 CPU를 할당하는 방식
- 프로세스가 자발적으로 CPU를 반납할 때까지 CPU를 선점하지 않는다. (비선점)
- 만약 CPU 버스트가 긴 프로세스가 먼저 도착하고 이후에 짧은 CPU 버스트 프로세스들이 들어온다면? (FCFS 단점)
  - 다수의 프로세스들이 긴 작업 하나 때문에 계속 기다려야 하므로 평균 대기 시간이 길어지게 된다.
  - I/O 장치들의 활용도도 하락

### SJF (Shortest Job First)
- CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식
- SJF 방식은 비선점과 선점 방식 두 가지로 구현될 수 있다.
- 비선점
  - CPU를 획득한 프로세스보다 더 짧은 CPU 버스트를 가진 프로세스가 들어와도 자진 반납하기 전까지 스케줄링을 하지 않는 방식
- 선점
  - CPU를 획득한 프로세스보다 더 짧은 CPU 버스트를 가진 프로세스가 들어오면 CPU를 빼앗아 더 짧은 프로세스에게 부여하는 방식
  - 이 방식을 SRTF (Shortest Remaining Time First) 라고도 한다.
- 계속 CPU 버스트가 짧은 프로세스가 들어오게 되면 CPU 버스트가 긴 프로세스는 무한정 기다려야 하는 문제도 발생할 수 있다. (SJF 단점)
  - 기아 현상 발생 (Starvation)