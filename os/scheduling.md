# CPU 스케줄링

## CPU 스케줄러
- 각 프로그램마다 CPU 버스트와 IO 버스트가 균일하지 않기 때문에 CPU가 놀지 않도록 프로세스를 선택하는 역할을 한다.
- `ready` 상태에 있는 프로세스들 중에 어떤 프로세스를 선택할지 결정하는 운영체제 코드이다.

<br>

- 오늘날 프로세스들의 CPU 버스트를 분석해보면 대부분 짧은 CPU 버스트 분포가 많다. 
  - 즉, CPU를 잠깐 사용하고 I/O 작업을 수행하는 프로세스들이 많다는 뜻이다.
- CPU 버스트가 짧은 프로세스는 대부분 빠른 응답이 중요한 사용자와 인터액션을 수행하는 작업을 수행한다. 
- 빠른 응답을 제공해야하기 때문에 CPU 스케줄링을 할 때 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용할 수 있는 스케줄링이 필요하다.

<br>

- CPU 스케줄링이 발생하는 상황은 다음과 같다.
1. `running` -> {`blocked` or `waiting`}
   - 실행 중인 상태에 있던 프로세스가 I/O 요청 등에 의해 대기 상태로 바뀌는 경우
2. `running` -> `ready`
   - 실행 중인 상태에 있던 프로세스가 인터럽트 콜에 의해 준비 상태로 바뀌는 경우
3. {`blocked` or `waiting`} -> `ready`
   - I/O 작업이 완료가 되어 인터럽트가 발생하고 그 결과 프로세스 상태가 준비 상태로 바뀌는 경우
4. `running` -> `terminated`
   - 실행 상태에 있는 프로세스가 종료되는 경우 

## 디스패처
- CPU 스케줄러가 어떤 프로세스에게 CPU를 할당해야 할지 결정하고나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요한데, 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 도와주는 커널 모듈을 말한다.
  - 즉, 스케줄러가 ready 상태에 있는 프로세스들 중에 어떤 프로세스를 선택할지 결정했다면
  - 디스패처는 선택된 프로세스에게 CPU를 할당하는 역할을 한다.
  - - _CPU와 관련된 작업들은 민감한 작업으로써 OS에서 조심스럽게 다뤄야 하기 때문에 보통 `커널 모드`에서 실행한다는 것을 기억해두자._
- 컨텍스트 스위칭을 디스패쳐가 한다.
- `커널 모드` -> `유저 모드`로 전환하는 것도 디스패처가 하는 역할 중 하나이다.
- 새롭게 선택된 프로세스가 어디서부터 작업을 시작해야할지 실행되어야할 위치로 프로세스를 이동시키는 역할도 한다. <br>
즉,
1. 디스패처는 커널 모드에서 현재 수행중이던 프로세스의 문맥을 PCB에 저장하고, 새로운 프로세스의 문맥을 PCB로부터 복원
2. 커널 모드에서 새로운 문맥을 복원후 CPU를 할당받게 해야하기 때문에 `유저 모드`로 전환 후 프로세스에게 CPU 제어권을 넘기게 된다.
3. 복원된 문맥을 통해 PC로 부터 현재 수행할 주소를 찾을 수 있게 된다.

- 이와 같이 디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기 걸리는 시간은 컨텍스트 스위칭 오버헤드에 해당한다.

<br>

## 스케줄링 선점 방식

### 비선점 (Non-Preemptive)
- CPU를 획득한 프로세스가 **스스로** CPU를 반납하기 전까지 CPU를 빼앗기지 않는 스케줄링 방법
- `running` 상태인 프로세스가 OS가 강제로 개입하는 일 없이 **자발적으로** `ready`, `waiting`, `terminated`으로 전환되어 다른 프로세스에게 CPU를 양보하는 것
- 프로세스가 끝날때까지 OS가 기다려주기 때문에 신사적이다
- 다른 프로세스에게 CPU를 사용하도록 양보하기에 협력적이다. 
- 만약 작업이 긴 프로세스라 할지라도 OS가 끝날때까지 기다려주기 때문에 느린 응답성이 특징이다.
  - 다른 프로세스들은 계속 대기하고 있게 된다.

### 선점 (Preemptive)
- CPU를 획득한 프로세스가 CPU를 계속 사용하기를 원하더라도 OS가 강제로 빼앗을 수 있는 스케줄링 방법
  - time slice를 부여한 후 타이머 인터럽트를 발생시켜 `ready` 상태로 전환시켜 대기시키거나
  - I/O 작업이 완료된 프로세스가 인터럽트 당한 프로세스보다 우선순위가 높아, 인터럽트 당한 프로세스가 아닌 I/O 작업이 완료된 프로세스에게 CPU를 할당하거나
  - `running` 상태인 프로세스보다 ready 상태에 있는 프로세스가 우선순위가 높아 아직 time slice가 끝나지 않았는데 `ready`로 전환시킨다.
- 비선점 방식이 하는 일 + OS 개입으로 인해 적극적이고 강제적인 스케줄링 방법.
- 여러 프로세스가 CPU를 자주 획득하는 방법이다보니 빠른 응답성이 특징이다.

<br>

## 스케줄링 알고리즘
### FCFS (First Come First Served)
- 프로세스가 준비 큐에 도착한 순서대로 CPU를 할당하는 방식
- 프로세스가 자발적으로 CPU를 반납할 때까지 CPU를 선점하지 않는다. (비선점)
- 만약 CPU 버스트가 긴 프로세스가 먼저 도착하고 이후에 짧은 CPU 버스트 프로세스들이 들어온다면? (FCFS 단점)
  - 다수의 프로세스들이 긴 작업 하나 때문에 계속 기다려야 하므로 평균 대기 시간이 길어지게 된다.
  - I/O 장치들의 활용도도 하락

### SJF (Shortest Job First)
- CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식
- SJF 방식은 비선점과 선점 방식 두 가지로 구현될 수 있다.
- 비선점
  - CPU를 획득한 프로세스보다 더 짧은 CPU 버스트를 가진 프로세스가 들어와도 자진 반납하기 전까지 스케줄링을 하지 않는 방식
- 선점
  - CPU를 획득한 프로세스보다 더 짧은 CPU 버스트를 가진 프로세스가 들어오면 CPU를 빼앗아 더 짧은 프로세스에게 부여하는 방식
  - 이 방식을 SRTF (Shortest Remaining Time First) 라고도 한다.
- 계속 CPU 버스트가 짧은 프로세스가 들어오게 되면 CPU 버스트가 긴 프로세스는 무한정 기다려야 하는 문제도 발생할 수 있다. (SJF 단점)
  - 기아 현상 발생 (Starvation)

### 우선순위 알고리즘 (Priority Scheduling)
- 우선순위가 높은 프로세스부터 실행
- 우선순위값이 작을수록 높은 순위를 가진다.
- 우선순위를 결정하는 방법은 여러가지가 있다.
  - CPU 버스트 시간
- 비선점과 선점형으로 구현할 수 있다.
- SJF 처럼 기아 현상이 발생할 수 있다.
  - 우선순위가 높은 프로세스가 계속해서 들어오면 우선순위가 낮은 프로세스는 무한히 대기하게 될 수도 있다.
  - 위 문제를 `노화 기법`을 사용하여 해결할 수 있다.
    - **기다리는 시간이 길어지면 그에 따라 우선순위를 높이는 방식**
    - 버스나 지하철에 어르신분들께 자리를 양보하는 것 처럼

### 라운드 로빈 (Round robin)
- 각 프로세스가 CPU를 사용할 수 있는 시간이 제한되며, time slice로 나눠진 CPU time을 번갈아가며 실행
  - time slice가 길어지면 FCFS와 같은 결과
  - time slice가 짧으면 context switching 오버헤드 발생
- 라운드 로빈의 목적은 CPU 버스트 시간이 짧은 프로세스가 빨리 CPU를 얻는 것과 CPU 버스트 시간이 긴 프로세스가 불이익을 당하지 않도록 하는 것


### 멀티 레벨 큐 (Multilevel queue)
- 프로세스들을 그룹화해서 그룹마다 큐를 두는 방식
  - 프로세스가 한 줄로 서있는 것이 아니라 여러 줄로 서서 대기
- 두 개의 큐가 있다고 가정했을 때, 큐마다 우선순위가 다르고 큐마다 스케줄링 방식이 존재, 스케줄러는 우선순위에 따라 큐를 결정하고 각 큐안에서 큐에 해당하는 스케줄링 방법으로 스케줄링
- 보통 빠른 응답이 필요한 전위 큐(Foreground queue)와 계산 위주의 작업을 담기 위한 후위 큐(Background queue)로 분할하여 운영한다.
  - 전위 큐에서는 응답 시간을 짧게 하기 위해 라운드 로빈 방식을 사용한다.
  - 후위 큐에서는 응답 시간이 의미가 없으므로 FCFS를 사용하여 컨텍스트 스위칭의 오버헤드를 줄인다.

<br>

- 어느 큐에 먼저 CPU를 할당할지 결정하는 스케줄링 방식은 다음과 같다.
1. 고정 우선순위 방식
    - 큐에 우선순위를 부여하여 우선순위 높은 큐 위주로 CPU를 할당한다.
    - 전위 큐가 비어있을 경우에만 후위 큐에 CPU를 할당한다.
2. 타임 슬라이스 방식
    - 각 큐에 CPU 시간을 적절한 비율로 할당한다.

### 멀티 레벨 피드백 큐 (Multilevel feedback queue)
- 멀티 레벨 큐 처럼 프로세스가 여러 큐에서 대기하는 방식
- 차이는 **프로세스가 다른 큐로 이동이 가능하다.**
- 우선순위 스케줄링에서 기아 현상을 해결하기 위한 노화 기법을 멀티 레벨 피드백 큐 방식으로 구현할 수 있다.
  - 우선순위가 낮은 큐에서 오래 기다렸다면 우선순위가 높은 큐로 승격하는 방식